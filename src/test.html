<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
    #container {
        width: 100%;
        height: 200px;
        line-height: 200px;
        text-align: center;
        color: #fff;
        background-color: #444;
        font-size: 30px;
    }
    </style>
</head>

<body>
    <div id="container"></div>
    <script type="text/javascript">
    // 防抖函数。
    // 防抖的目的是：高频（由 wait 来确定）操作下只响应一次。
    // 常应用于：resize、scroll、mousedown、mousemove等；文本输入的验证（keyup、keydown）。
    // immediate：false（默认），可以执行时也必须延后至少 wait 个时间才能执行。
    // immediate：true，可以执行时立即执行。
    function debounce(func, wait, immediate) {
        var timeout, result;
        var debounced = function() {
            var context = this;
            var args = arguments;

            if (timeout) clearTimeout(timeout);
            if (immediate) {
                // 如果有定时器，说明执行过了，不再执行。
                // 如果有定时器，说明执行还在等候时间内，不再执行，否则立即执行。
                var callNow = !timeout;
                // 持续触发时，依然有定时器（callNow 为 false），
                timeout = setTimeout(function() {
                    // 执行时，清空定时器标志，意味着回到初始状态。
                    timeout = null;
                }, wait);
                // 立即执行。只有在立即执行的情况下，返回值才有意义。
                if (callNow) result = func.apply(context, args)
            } else {
                // 延迟执行。
                timeout = setTimeout(function() {
                    func.apply(context, args);
                }, wait);
            }
            return result;
        };

        // 取消防抖（主要用于在等候时间内，想回到初始状态，立即执行），变成初始状态。
        debounced.cancel = function() {
            clearTimeout(timeout);
            timeout = null;
        };

        return debounced;
    }

    // 节流函数。
    /*function throttle(func, wait) {
        var previous = 0;
        var throttled = function() {
            var context = this;
            var args = arguments;
            var now = new Date();

            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }
        return throttled;
    }*/

    /*function throttle(func, wait) {
        var timeout;
        var throttled = function() {
            var context = this;
            var args = arguments;

            if (!timeout) {
                timeout = setTimeout(function() {
                    func.apply(context, args);
                    timeout = null;
                }, wait);
            }
        }
        return throttled;
    }*/

    function throttle(func, wait) {
        var timeout, result, context, args;
        var previous = 0;

        var later = function() {
            // +new Date() 将时间类型转换成数值类型，即 new Date().valueOf() 也等于 new Date().getTime()。
            previous = +new Date();
            timeout = null;
            func.apply(context, args);
        }

        var throttled = function() {
            context = this;
            args = arguments;

            var now = +new Date();
            var remaining = wait - (now - previous);

            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                func.apply(context, args);
            } else if (!timeout) {
                timeout = setTimeout(later, remaining);
            }
        }
        return throttled;
    }

    var count = 0;
    var container = document.getElementById('container');

    function showCount() {
        container.innerHTML = count++;
    }

    // 防抖示例
    // container.onmousemove = debounce(showCount, 1000, false);
    // container.onmousemove = debounce(showCount, 1000, false);

    // 节流示例
    container.onmousemove = throttle(showCount, 3000);
    </script>
</body>

</html>